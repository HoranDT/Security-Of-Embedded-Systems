# -*- coding: utf-8 -*-
"""Task1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14mDVlQJPK0DcqKYErOd731A5YikEZTf-

Code For Task 1:
"""

import scipy.io
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime

#This loads the power consumption data from a MATLAB file
mat = scipy.io.loadmat('aes_power_data.mat')

plaintext = mat['plain_text'] #Extracts plaintext from the loaded file
traces = mat['traces'][0:200, :] #Extracts traces from the loaded file
sbox = mat['sbox'][0] #Extracts S-box data from the loaded file

byte_to_attack = 16  #The byte of the plaintext we are targeting
key_guesses = np.arange(256)  #All possible byte values (0 to 255)

#Initializes a matrix to store the DoM for each key guess
DoM = np.zeros((256, 40000))

#DPA Attack loop
for key_guess in key_guesses:
    group_0, group_1 = [], []  #Creates two empty groups for classification based on the LSB of S-box output
    for i in range(200):
        #Computes the S-box output for the current plaintext byte XORed with the key guess
        sbox_out = sbox[plaintext[i, byte_to_attack - 1] ^ key_guess]
        #Classifies the trace into one of the groups based on the LSB
        if sbox_out & 1:
            group_1.append(traces[i, :])
        else:
            group_0.append(traces[i, :])
    #Calculates the DoM for the current key guess and store in the matrix
    DoM[key_guess, :] = np.mean(group_1, axis=0) - np.mean(group_0, axis=0)

#Plots the DoM values for a subset of the key guesses
offset = 192
N = 8
plt.figure(figsize=(15, 15))  #Increases the size of the figure
for i in range(N):
    for j in range(N):
        idx = i * N + j + offset
        plt.subplot(N, N, (i * N + j) + 1)
        plt.plot(DoM[idx, :])
        plt.title(f'Key: {hex(idx)[2:].zfill(2).upper()}')
        plt.xticks([])  #Removes x-axis ticks for clarity
        plt.yticks([])  #Removes y-axis ticks for clarity

netid = "527005307" #Adds NetID to the plot
timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S') #Adds a timestamp to the plot
legend_text = f'NetID: {netid}\nTimestamp: {timestamp}'
plt.figlegend([legend_text], loc='upper right')
plt.tight_layout()  #Adjusts subplot spacing for better visualization

plt.show()