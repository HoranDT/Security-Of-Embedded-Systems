# -*- coding: utf-8 -*-
"""Task2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14mDVlQJPK0DcqKYErOd731A5YikEZTf-

Code One (Standard DPA Attack) For Task 2:
"""

import scipy.io
import numpy as np
from datetime import datetime

#Loads power consumption data from a MATLAB file
mat = scipy.io.loadmat('aes_power_data.mat')

plaintext = mat['plain_text'] #Extracts plaintext, traces, and S-box data
traces = mat['traces'][0:200, :] #Extracts traces data
sbox = mat['sbox'][0] #Extracts S-box data

#All possible byte values (0 to 255) for key guessing
key_guesses = np.arange(256)

#Conducta the DPA attack on a specific byte of the key
def dpa_attack(byte_to_attack):
    #Initializes a matrix to store the Difference of Means for each key guess
    DoM = np.zeros((256, 40000))
    for key_guess in key_guesses:
        group_0, group_1 = [], []  #Creates two empty groups based on the LSB of S-box output
        for i in range(200):
            #Computes the S-box output for plaintext byte XORed with the key guess
            sbox_out = sbox[plaintext[i, byte_to_attack - 1] ^ key_guess]
            #Sorts the trace based on the LSB of the S-box output
            if sbox_out & 1:
                group_1.append(traces[i, :])
            else:
                group_0.append(traces[i, :])
        #Calculates the Difference of Means for the current key guess and store in the matrix
        DoM[key_guess, :] = np.mean(group_1, axis=0) - np.mean(group_0, axis=0)
    return DoM

#Recovers all 16 bytes of the AES key by performing the DPA attack on each byte
recovered_key = []
for byte_pos in range(1, 17):
    DoM = dpa_attack(byte_pos)
    #Identifies the key guess with the highest absolute DoM value
    max_dom_value = np.max(np.abs(DoM), axis=1)
    key_byte_guess = np.argmax(max_dom_value)
    recovered_key.append(key_byte_guess)

#Converts the recovered key bytes to hexadecimal format
recovered_key_hex = [hex(byte)[2:].zfill(2).upper() for byte in recovered_key]
print(f"Recovered Key: {' '.join(recovered_key_hex)}")

#Samples actual key for comparison
actual_key = [0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF]

#Calculates the total number of bits that match between the actual and recovered keys
correct_bits = sum(bin(a ^ b).count('0') for a, b in zip(actual_key, recovered_key))

#Computes the accuracy of the key recovery
accuracy = (correct_bits / 128) * 100
print(f'Accuracy: {accuracy:.2f}%')

"""Code Two (DPA Attack Using AdelineSGD) For Task 2:"""

import numpy as np
import scipy.io
from datetime import datetime
from sklearn.model_selection import train_test_split

#Loads power consumption data from a MATLAB file
mat = scipy.io.loadmat('aes_power_data.mat')

plaintext = mat['plain_text'] #Extracts plaintext, traces, and S-box data
traces = mat['traces'][0:200, :] #Extracts traces data
sbox = mat['sbox'][0] #Extracts S-box data

#AdalineSGD classifier definition
class AdalineSGD(object):
    #Initializes the classifier parameters
    def __init__(self, eta=0.01, n_iter=10, shuffle=True, random_state=None):
        self.eta = eta
        self.n_iter = n_iter
        self.w_initialized = False
        self.shuffle = shuffle
        if random_state:
            np.random.seed(random_state)

    #Trains the classifier on provided data
    def fit(self, X, y):
        self._initialize_weights(X.shape[1])
        self.cost_ = []
        for i in range(self.n_iter):
            if self.shuffle:
                X, y = self._shuffle(X, y)
            cost = []
            for xi, target in zip(X, y):
                cost.append(self._update_weights(xi, target))
            avg_cost = sum(cost) / len(y)
            self.cost_.append(avg_cost)
        return self

    #Shuffles the dataset
    def _shuffle(self, X, y):
        r = np.random.permutation(len(y))
        return X[r], y[r]

    #Initializes weights
    def _initialize_weights(self, m):
        self.w_ = np.zeros(1 + m)
        self.w_initialized = True

    #Updates the weights based on error
    def _update_weights(self, xi, target):
        output = self.activation(xi)
        error = target - output
        self.w_[1:] += self.eta * xi.dot(error)
        self.w_[0] += self.eta * error
        cost = 0.5 * error**2
        return cost

    #Computes net input
    def net_input(self, X):
        return np.dot(X, self.w_[1:]) + self.w_[0]

    #Activation function
    def activation(self, X):
        return self.net_input(X)

    #Makes predictions based on the learned model
    def predict(self, X):
        return np.where(self.activation(X) >= 0.0, 1, -1)

#Performs DPA attack on a single byte using AdalineSGD
def adaline_dpa_attack(byte_to_attack):
    best_guess = 0
    best_accuracy = 0

    #Loops through all possible key guesses
    for key_guess in range(256):
        #Generates labels for the current key guess
        labels = np.array([1 if sbox[pt ^ key_guess] & 1 else -1 for pt in plaintext[:, byte_to_attack]])

        #Splits the dataset into training and testing sets
        X_train, X_test, y_train, y_test = train_test_split(traces, labels, test_size=0.2, random_state=42)

        #Trains the AdalineSGD classifier
        ada = AdalineSGD(n_iter=15, eta=0.01, random_state=1)
        ada.fit(X_train, y_train)

        #Evaluates the classifier on the testing set
        y_pred = ada.predict(X_test)
        accuracy = np.mean(y_test == y_pred)

        #Tracks the best key guess based on accuracy
        if accuracy > best_accuracy:
            best_accuracy = accuracy
            best_guess = key_guess

    return best_guess

#Recovers all 16 bytes of the AES key using AdalineSGD-based DPA
recovered_key = []
for byte_pos in range(16):
    recovered_byte = adaline_dpa_attack(byte_pos)
    recovered_key.append(recovered_byte)

#Converts the recovered key to hexadecimal format
recovered_key_hex = [hex(byte)[2:].zfill(2).upper() for byte in recovered_key]
print(f"Recovered Key: {' '.join(recovered_key_hex)}")

#Samples actual key for comparison
actual_key = [0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF]

#Calculates the number of matching bits between the actual and recovered keys
correct_bits = sum(bin(a ^ b).count('0') for a, b in zip(actual_key, recovered_key))

#Computes and print the accuracy of the key recovery
accuracy = (correct_bits / 128) * 100
print(f'Accuracy: {accuracy:.2f}%')

print(f"Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
print(f"NetID: 527005307")