# -*- coding: utf-8 -*-
"""Task3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14mDVlQJPK0DcqKYErOd731A5YikEZTf-

Code One (Standard DPA Attack) For Task 3:
"""

import scipy.io
import numpy as np
from datetime import datetime

#Loads power consumption data and other necessary data from a MATLAB file
mat = scipy.io.loadmat('aes_power_data.mat')

plaintext = mat['plain_text'] #Extracts plaintext
sbox = mat['sbox'][0] #sExtract S-box values
actual_key = [0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF]

#Potential key byte values for the AES key
key_guesses = np.arange(256)

#Performs the DPA attack for a specific byte of the AES key
def dpa_attack(byte_to_attack, n_traces):
    #Limits the number of power traces based on the input parameter
    traces = mat['traces'][0:n_traces, :]
    DoM = np.zeros((256, 40000))
    for key_guess in key_guesses:
        group_0 = []
        group_1 = []
        for i in range(n_traces):
            sbox_out = sbox[plaintext[i, byte_to_attack - 1] ^ key_guess]
            #Splits traces based on LSB of the S-box output
            if sbox_out & 1:
                group_1.append(traces[i, :])
            else:
                group_0.append(traces[i, :])
        #Computes the DoM for this key guess
        DoM[key_guess, :] = np.mean(group_1, axis=0) - np.mean(group_0, axis=0)
    return DoM

#Recovers all 16 bytes of the AES key using DPA
def recover_key(n_traces):
    recovered_key = []
    for byte_pos in range(1, 17):
        DoM = dpa_attack(byte_pos, n_traces)
        max_dom_value = np.max(np.abs(DoM), axis=1)
        key_byte_guess = np.argmax(max_dom_value)
        recovered_key.append(key_byte_guess)
    return recovered_key

recovered_key_hex = [hex(byte)[2:].zfill(2).upper() for byte in recovered_key]

#Computes the accuracy of the recovered AES key against the actual key
def calculate_accuracy(recovered_key):
    correct_bits = sum(bin(a ^ b).count('0') for a, b in zip(actual_key, recovered_key))
    accuracy = (correct_bits / 128) * 100
    return accuracy

#Performs the DPA attack using different numbers of power traces and print the accuracy
for n_traces in [20, 50, 100, 200]:
    recovered_key = recover_key(n_traces)
    accuracy = calculate_accuracy(recovered_key)
    print(f'Number of Traces: {n_traces}, Accuracy: {accuracy:.2f}%')
    print(f"Recovered Key: {' '.join(recovered_key_hex)}")
    print("-------------------------------------------------")

print(f"Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
print(f"NetID: 527005307")

"""Code Two (DPA Attack Using AdelineSGD) For Task 3:"""

import scipy.io
import numpy as np
from datetime import datetime
from sklearn.model_selection import train_test_split

#Loads power consumption data from a MATLAB file
mat = scipy.io.loadmat('aes_power_data.mat')

plaintext = mat['plain_text'] #Extracts plaintext
traces = mat['traces'] #Extracts traces
sbox = mat['sbox'][0] #Extracts S-Box
actual_key = [0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF]

# AdalineSGD definition
class AdalineSGD(object):
    #Initializes of the classifier parameters
    def __init__(self, eta=0.01, n_iter=10, shuffle=True, random_state=None):
        self.eta = eta
        self.n_iter = n_iter
        self.w_initialized = False
        self.shuffle = shuffle
        if random_state:
            np.random.seed(random_state)

    #Trains the classifier on provided data
    def fit(self, X, y):
        self._initialize_weights(X.shape[1])
        self.cost_ = []
        for i in range(self.n_iter):
            if self.shuffle:
                X, y = self._shuffle(X, y)
            cost = []
            for xi, target in zip(X, y):
                cost.append(self._update_weights(xi, target))
            avg_cost = sum(cost) / len(y)
            self.cost_.append(avg_cost)
        return self

    #Shuffles the dataset
    def _shuffle(self, X, y):
        r = np.random.permutation(len(y))
        return X[r], y[r]

    #Initializesg weights
    def _initialize_weights(self, m):
        self.w_ = np.zeros(1 + m)
        self.w_initialized = True

    #Updates the weights based on error
    def _update_weights(self, xi, target):
        output = self.activation(xi)
        error = target - output
        self.w_[1:] += self.eta * xi.dot(error)
        self.w_[0] += self.eta * error
        cost = 0.5 * error**2
        return cost

    #Computes net input
    def net_input(self, X):
        return np.dot(X, self.w_[1:]) + self.w_[0]

    #Activation function
    def activation(self, X):
        return self.net_input(X)

    #Makes predictions based on the learned model
    def predict(self, X):
        return np.where(self.activation(X) >= 0.0, 1, -1)

#Performs DPA attack on a single byte
def adaline_dpa_attack(byte_to_attack, n_traces):
    traces_subset = traces[:n_traces, :]
    best_guess = 0
    best_accuracy = 0

    #Loops through all possible key guesses
    for key_guess in range(256):
        #Generates binary labels for the current key guess
        labels = np.array([1 if sbox[pt ^ key_guess] & 1 else -1 for pt in plaintext[:n_traces, byte_to_attack]])

        #Splits data into training and testing sets
        X_train, X_test, y_train, y_test = train_test_split(traces_subset, labels, test_size=0.2, random_state=42)

        #Trains the AdalineSGD classifier
        ada = AdalineSGD(n_iter=15, eta=0.01, random_state=1)
        ada.fit(X_train, y_train)

        #Evaluates classifier's accuracy on test data
        y_pred = ada.predict(X_test)
        accuracy = np.mean(y_test == y_pred)

        #Tracks the best key guess based on accuracy
        if accuracy > best_accuracy:
            best_accuracy = accuracy
            best_guess = key_guess

    return best_guess

#Conducts DPA attack with different numbers of traces and display results
for n_traces in [20, 50, 100, 200]:
    recovered_key = []
    for byte_pos in range(16):
        recovered_byte = adaline_dpa_attack(byte_pos, n_traces)
        recovered_key.append(recovered_byte)

    #Converts the recovered key bytes to hexadecimal format
    recovered_key_hex = [hex(byte)[2:].zfill(2).upper() for byte in recovered_key]

    #Calculates the number of matching bits between the actual and recovered keys
    correct_bits = sum(bin(a ^ b).count('0') for a, b in zip(actual_key, recovered_key))

    #Displays the accuracy of the key recovery
    accuracy = (correct_bits / 128) * 100
    print(f'Number of Traces: {n_traces}, Accuracy: {accuracy:.2f}%')
    print(f"Recovered Key: {' '.join(recovered_key_hex)}")
    print("-------------------------------------------------")

print(f"Timestamp: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
print(f"NetID: 527005307")